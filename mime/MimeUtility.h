//=============================================================================
/**
 *  @file    MimeUtility.h
 *
 *  ver 1.0.0 2004/06/16 Naven Exp, for Mime Message Parse Engine.
 *
 *  @author Naven 2004/06/16 created.
 */
//=============================================================================

#ifndef _MIMEUTILITY_H
#define _MIMEUTILITY_H

#if defined(_WIN32) || defined(__WIN32__)

#if !defined (NAVEN_PRAGMA_ONCE)
# pragma once
#endif /* NAVEN_PRAGMA_ONCE */

#endif /* _WIN32 */


#include <time.h>
#include "MimeBase.h" 
#include "MimeParser.h"


_FASTMIME_BEGIN_NAMESPACE



//=============class UniqueValue define==============

/**
 * This is a utility class that generates unique values. The generated
 * String contains only US-ASCII characters and hence is safe for use
 * in RFC822 headers. <p>
 *
 * This is a package private class.
 *
 */
class UniqueValue
{
private: 
    static ShortString PART; 
    static ShortString FASTMAIL; 

    /**
     * A global part number.  Access is not synchronized because the
     * value is only one part of the unique value and so doesn't need
     * to be accurate.
     */
    static int m_nParts; 

    /**
     * A global cid number.  Access is not synchronized because the
     * value is only one part of the unique value and so doesn't need
     * to be accurate.
     */
    static int m_nCIDs; 

    /**
     * A global attachment number. 
     */
    static int m_nAttachments; 

public:
    /**
     * Get a unique value for use in a multipart boundary string.
     *
     * This implementation generates it by concatenating a global
     * part number, a newly created object's <code>hashCode()</code>,
     * and the current time (in milliseconds).
     */
    static void getUniqueBoundaryValue(FastString &s); 

    /**
     * Get a unique value for use in a Message-ID.
     *
     * This implementation generates it by concatenating a newly
     * created object's <code>hashCode()</code>, the current
     * time (in milliseconds), the string "FastMail", and
     * this user's local address generated by 
     * <code>InternetAddress.getLocalAddress()</code>.
     * (The address defaults to "javamailuser@localhost" if
     * <code>getLocalAddress()</code> returns null.)
     *
     */
    static void getUniqueMessageIDValue(FastString &s); 

    /**
     * Get a unique value for use in a Content-ID.
     *
     * This implementation generates it by concatenating a newly
     * created object's <code>hashCode()</code>, the current
     * time (in milliseconds), the string "FastMail", and
     * this user's local address generated by 
     * <code>InternetAddress.getLocalAddress()</code>.
     * (The address defaults to "javamailuser@localhost" if
     * <code>getLocalAddress()</code> returns null.)
     *
     */
    static void getUniqueContentIDValue(FastString &s); 

    /**
     * Get a unique value for use in a attachment bodypart 
     * without filename.
     */
    static void getUniqueAttachmentValue(FastString &s, FastString &mimetype); 
    static void getUniqueAttachmentValue(FastString &s, const char *mimetype = NULL); 

    /**
     * Get a unique value for use in a <code>text/plain</code> 
     * attachment bodypart without filename.
     */
    static void getUniqueAttachmentTextPlainValue(FastString &s); 

    /**
     * Get a unique value for use in a <code>text/html</code> 
     * attachment bodypart without filename.
     */
    static void getUniqueAttachmentTextHtmlValue(FastString &s); 

    friend class MimeInitialization; 
};


//=============UniqueValue inline functions===============

/**
 * Get a unique value for use in a attachment bodypart 
 * without filename.
 */
inline void UniqueValue::getUniqueAttachmentValue(FastString &s, const char *mimetype) 
{
    FastString sMimeType(mimetype); 
    getUniqueAttachmentValue(s, sMimeType); 
}


//=============class MimeUtility define==============

/**
 * This is a utility class that provides various MIME related
 * functionality. <p>
 *
 * There are a set of methods to encode and decode MIME headers as 
 * per RFC 2047. A brief description on handling such headers is
 * given below: <p>
 *
 * RFC 822 mail headers <strong>must</strong> contain only US-ASCII
 * characters. Headers that contain non US-ASCII characters must be
 * encoded so that they contain only US-ASCII characters. Basically,
 * this process involves using either BASE64 or QP to encode certain
 * characters. RFC 2047 describes this in detail. <p>
 * 
 * The <code>setHeader</code> and <code>addHeader</code> methods
 * on MimeMessage and MimeBodyPart assume that the given header values
 * are Unicode strings that contain only US-ASCII characters. Hence
 * the callers of those methods must insure that the values they pass
 * do not contain non US-ASCII characters. The methods in this class 
 * help do this. <p>
 *
 * The <code>getHeader</code> family of methods on MimeMessage and
 * MimeBodyPart return the raw header value. These might be encoded
 * as per RFC 2047, and if so, must be decoded into Unicode Strings.
 * The methods in this class help to do this. <p>
 *
 * The <code>mail.mime.decodetext.strict</code> property controls
 * decoding of MIME encoded words.  The MIME spec requires that encoded
 * words start at the beginning of a whitespace separated word.  Some
 * mailers incorrectly include encoded words in the middle of a word.
 * If the <code>mail.mime.decodetext.strict</code> System property is
 * set to <code>"false"</code>, an attempt will be made to decode these
 * illegal encoded words. The default is true. <p>
 *
 * The <code>mail.mime.encodeeol.strict</code> property controls the
 * choice of Content-Transfer-Encoding for MIME parts that are not of
 * type "text".  Often such parts will contain textual data for which
 * an encoding that allows normal end of line conventions is appropriate.
 * In rare cases, such a part will appear to contain entirely textual
 * data, but will require an encoding that preserves CR and LF characters
 * without change.  If the <code>mail.mime.encodeeol.strict</code>
 * System property is set to <code>"true"</code>, such an encoding will
 * be used when necessary.  The default is false. <p>
 *
 * In addition, the <code>MIMEMESSAGE_CHARSET</code> System property can
 * be used to specify the default MIME charset to use for encoded words
 * and text parts that don't otherwise specify a charset.  Normally, the
 * default MIME charset is derived from the default Java charset, as
 * specified in the <code>file.encoding</code> System property.  Most
 * applications will have no need to explicitly set the default MIME
 * charset.  In cases where the default MIME charset to be used for
 * mail messages is different than the charset used for files stored on
 * the system, this property should be set.
 *
 * @version 1.00, 20040626
 * @author  Naven
 */
class MimeUtility
{
public: 
    enum{   UNKNOWN_ASCII  = 0,         // All ASCII Types
            ALL_ASCII,
            MOSTLY_ASCII, 
            MOSTLY_NONASCII, 

            MAX_ASCIITYPE
        };

private:
    static ShortString m_sDefaultMIMECharset; 

public:
    static void setDefaultMIMECharset(FastString &s); 
    static void setDefaultMIMECharset(const FastString &s); 
    static void setDefaultMIMECharset(const char *s); 
    static void getDefaultMIMECharset(FastString &s); 
    static const ShortString& getDefaultMIMECharset(); 

    static void doEncode(FastString &s, int b64, FastString &charset, 
                        int avail, FastString &prefix, 
                        int first, int encodingWord, int foldEncodedWords, 
                        FastString &buf); 
    static int  checkAscii(FastString &s); 
    static void getEncoding(IMimePart &part, FastString &encoding); 
    static void getEncoding(FastString &s, FastString &encoding); 
    static void quote(FastString &word, FastString &specials); 
    static void quote(FastString &word, const char *specials); 
    static void quotePhrase(FastString &word); 
    static void unquote(FastString &s); 
    static void unquoteAddress(FastString &addr); 
    static void fold(FastString &s, int used = 0); 
    static void unfold(FastString &s); 

    static int  getHeaderCount(const char *header, size_t headersize); 
    static int  getHeaderField(const char *header, size_t headersize, 
                        FastString &name, FastString &s, 
                        char *&valstart, size_t &valsize, 
                        size_t startpos = 0, size_t len = 0); 
    static char *findStartLine(const char *buf, const size_t len); 
    static char *findEndLine(const char *buf, const size_t len); 
    static char *ignoreCharsForward(const char *start, const char *end, const char *ignore_chars); 
    static char *ignoreCharsBackward(const char *start, const char *end, const char *ignore_chars); 
    static BOOL equalsRegion(const char *s1_start, const char *s1_end, 
                             const char *s2_start, const char *s2_end); 
    static char *findHeaderEnd(const char *buf, const size_t len); 
    static char *findBeginMailPos(const char *buf); 
    static char *findEndMailPos(const char *begin, FastString &mailname, FastString &mailaddr); 
    static char *getAddress(const char *buf, FastString &mailname, FastString &mailaddr); 

    static void decode(FastString &s, FastString &ds, FastString &encoding); 
    static void decode(FastString &s, FastString &ds, const char *encoding); 
    static void encode(FastString &s, FastString &ds, FastString &encoding); 
    static void encode(FastString &s, FastString &ds, const char *encoding); 
    static void decodeAddress(FastString &s); 
    static void decodeText(FastString &etext); 
    static void decodeInnerWords(FastString &word); 
    static void decodeWord(FastString &eword); 
    static void encodeWord(FastString &word, FastString &eword, FastString &charset, 
                        FastString &encoding, int encodingWord = 1, int foldEncodedWords = 1); 
    static void encodeWord(FastString &word, FastString &eword, int foldEncodedWords = 1, 
                        const char *charset = NULL, const char *encoding = NULL); 

    static int  checkAddress(FastString &addr, int routeAddr, int validate); 
    static int  parseAddress(InternetAddressArray &addrs, FastString &s, 
                        int strict = 1, int parseHdr = 0); 
    static int  parseHeaderAddress(InternetAddressArray &addrs, FastString &s, 
                        int strict = 0); 
    static int  getAddressGroups(InternetAddressArray &addrs, FastStringArray &groups); 
    static int  getGroupAddress(InternetAddressArray &addrs, FastString &name, InternetAddressArray &grpaddrs); 
    static void getAddressString(InternetAddressArray &addrs, FastString &s); 
    static int  replaceSrcWithCIDURL(FastString &html, FastString &src, FastString &cidurl); 
    static int  replaceSrcWithCIDURL(FastString &html, FastString &src, const char *cidurl); 
    static int  replaceSrcWithCIDURL(FastString &html, const char *src, const char *cidurl); 
    // add by henh 2012/7/20 16:13:31 for getCharset
    static void getCharset(FastString s, FastString &charset);
    static BOOL emptyOfSubject(FastString &eword, FastString &rmword);
    // add end

};


//=============MimeUtility inline functions===============

/*
 * Set the default MIME charset for this locale.
 */
inline void MimeUtility::setDefaultMIMECharset(FastString &s) 
{ 
    if( !s.empty() ) 
        m_sDefaultMIMECharset.set(s.c_str(), s.length()); 
}

/*
 * Set the default MIME charset for this locale.
 */
inline void MimeUtility::setDefaultMIMECharset(const FastString &s) 
{ 
    if( !s.empty() ) 
        m_sDefaultMIMECharset.set(s.c_str(), s.length()); 
}

/*
 * Set the default MIME charset for this locale.
 */
inline void MimeUtility::setDefaultMIMECharset(const char *s) 
{ 
    setDefaultMIMECharset(FastString(s)); 
}

/*
 * Get the default MIME charset for this locale.
 */
inline void MimeUtility::getDefaultMIMECharset(FastString &s) 
{ 
    if( m_sDefaultMIMECharset.empty() ) 
        m_sDefaultMIMECharset = DEFAULT_MIME_CHARSET; 
    s.set(m_sDefaultMIMECharset.c_str(), m_sDefaultMIMECharset.length()); 
}

/*
 * Get the default MIME charset for this locale.
 */
inline const ShortString& MimeUtility::getDefaultMIMECharset() 
{ 
    return m_sDefaultMIMECharset; 
}

/**
 * A utility method to quote a word, if the word contains any
 * characters from the specified 'specials' list.<p>
 *
 * The <code>HeaderTokenizer</code> class defines two special
 * sets of delimiters - MIME and RFC 822. <p>
 *
 * This method is typically used during the generation of 
 * RFC 822 and MIME header fields.
 *
 * @param   word    word to be quoted
 * @param   specials the set of special characters
 * @return  the possibly quoted word to param word
 */
inline void MimeUtility::quote(FastString &word, const char *specials) 
{
    FastString sSpecials(specials); 
    MimeUtility::quote(word, sSpecials); 
}

/**
 * Parse the given sequence of addresses into InternetAddress
 * objects.  If <code>strict</code> is false, the full syntax rules for
 * individual addresses are not enforced.  If <code>strict</code> is
 * true, many (but not all) of the RFC822 syntax rules are enforced. <p>
 *
 * To better support the range of "invalid" addresses seen in real
 * messages, this method enforces fewer syntax rules than the
 * <code>parse</code> method when the strict flag is false
 * and enforces more rules when the strict flag is true.  If the
 * strict flag is false and the parse is successful in separating out an
 * email address or addresses, the syntax of the addresses themselves
 * is not checked.
 *
 * @param addrs     array of InternetAddress objects
 * @param s            comma separated address strings
 * @param strict    enforce RFC822 syntax
 */
inline int MimeUtility::parseHeaderAddress(
    InternetAddressArray &addrs, FastString &s, int strict) 
{
    return parseAddress(addrs, s, strict, 1); 
}

/**
 * Encode a RFC 822 "word" token into mail-safe form as per
 * RFC 2047. <p>
 *
 * The given Unicode string is examined for non US-ASCII
 * characters. If the string contains only US-ASCII characters,
 * it is returned as-is.  If the string contains non US-ASCII
 * characters, it is first character-encoded using the specified
 * charset, then transfer-encoded using either the B or Q encoding.
 * The resulting bytes are then returned as a Unicode string 
 * containing only ASCII characters. <p>
 * 
 * @param   word    Unicode string
 * @param   charset the MIME charset
 * @param   encoding the encoding to be used. Currently supported
 *        values are "B" and "Q". If this parameter is null, then
 *        the "Q" encoding is used if most of characters to be
 *        encoded are in the ASCII charset, otherwise "B" encoding
 *        is used.
 * @param   eword   Unicode string containing only US-ASCII characters
 */
inline void MimeUtility::encodeWord(
    FastString &word, FastString &eword, int foldEncodedWords, 
    const char *charset, const char *encoding) 
{
    FastString faCharset(charset), faEncoding(encoding); 
    MimeUtility::encodeWord(word, eword, faCharset, faEncoding, 
        TRUE, foldEncodedWords); 
}

/**
 * Decode the given input string. The Input string returned is
 * the decoded string. All the encodings defined in RFC 2045
 * are supported here. They include "base64", "quoted-printable",
 * "7bit", "8bit", and "binary". In addition, "uuencode" is also
 * supported.
 *
 * @param s         input string
 * @param encoding  the encoding of the string.
 * @param ds        output string
 */
inline void MimeUtility::decode(FastString &s, FastString &ds, const char *encoding) 
{
    FastString fsEncoding(encoding); 
    MimeUtility::decode(s, ds, fsEncoding); 
}

/**
 * Wrap an encoder around the given output stream. 
 * All the encodings defined in RFC 2045 are supported here. 
 * They include "base64", "quoted-printable", "7bit", "8bit" and
 * "binary". In addition, "uuencode" is also supported.
 *
 * @param s         input string
 * @param encoding  the encoding of the string. 
 * @param ds        output string that applies the
 *                specified encoding.
 */
inline void MimeUtility::encode(FastString &s, FastString &ds, const char *encoding) 
{
    FastString fsEncoding(encoding); 
    MimeUtility::encode(s, ds, fsEncoding); 
}

/**
 * Replace the src string with cidurl in html. this should use HTML or XML 
 * parser. now is sample replacement. 
 *
 * @param html      html main bodytext string
 * @param src       attachment src name in html, include filename
 * @param cidurl    attachment cidurl
 */
inline int MimeUtility::replaceSrcWithCIDURL(FastString &html, FastString &src, 
                                             const char *cidurl) 
{
    FastString sCIDURL(cidurl); 
    return replaceSrcWithCIDURL(html, src, sCIDURL); 
}

/**
 * Replace the src string with cidurl in html. this should use HTML or XML 
 * parser. now is sample replacement. 
 *
 * @param html      html main bodytext string
 * @param src       attachment src name in html, include filename
 * @param cidurl    attachment cidurl
 */
inline int MimeUtility::replaceSrcWithCIDURL(FastString &html, const char *src, 
                                             const char *cidurl) 
{
    FastString sSRC(src), sCIDURL(cidurl); 
    return replaceSrcWithCIDURL(html, sSRC, sCIDURL); 
}

/**
 * Gets the string part charset. The string must be like this "=?UTF-8?B?3NzIz?=" format
 *
 * @param s      The string must be like this "=?UTF-8?B?3NzIz?=" format
 * @param charset       The output part charset, such as UTF-8
 */
inline void MimeUtility::getCharset(FastString s, FastString &charset)
{
	char lwsp[] = " \t\n\r"; 
	s.trimChars(lwsp);
	charset.clear();
	if(!s.empty())
	{
		int pos1 = s.indexOf("=?");
		if( pos1 >-1 )
		{
			int pos2 = s.indexOf('?',pos1+2);
			if( pos2 >-1 )
			{
				charset=s.substr(pos1+2,pos2-pos1-2);
				charset.removeChars(" \r\n\t");
			}
		}
	}
}

/**
 * Determines whether a string is empty. The string must be like this "=?UTF-8?B??=" format
 *
 * @param s      The string must be like this "=?UTF-8?B?3NzIz?=" format
 * @param s      return "=?UTF-8?B??="
 */
inline BOOL MimeUtility::emptyOfSubject(FastString &eword, FastString &rmword)
{
	int pos = 0, startpos = 0;
  size_t start = 0;
  
  rmword.clear();

  // not an encoded word
  if( eword.empty() )
      return TRUE;
  else if( (pos = eword.indexOf("=?")) < 0 )
  		return FALSE;  

  // for hold the not encoded string in the eword's left
  startpos = pos; 

  // get charset
  start = pos + 2; 
  if( (pos = eword.indexOf('?', start)) < 0 ) 
      return FALSE; 
  //FastString charset; 
  //eword.substring(charset, start, pos - start); 

  // get encoding
  start = pos + 1; 
  if( (pos = eword.indexOf('?', start)) < 0 ) 
      return FALSE; 
  FastString encoding; 
  eword.substring(encoding, start, pos - start); 

  // get encoded-sequence
  start = pos + 1; 
  if( (pos = eword.indexOf("?=", start)) < 0 ) 
      return FALSE; 
  FastString word, dword; 
  eword.substring(word, start, pos - start); 

  // remove the whitespace.
  word.removeChars(" \t\r\n");
    
  if(word.empty())
  {
  	eword.substring(rmword, startpos, pos+2-startpos); 
  	return TRUE;
  }
  
  return FALSE;
}


_FASTMIME_END_NAMESPACE

#endif
